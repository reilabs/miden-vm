#! Reverses order of the first four elements on the stack
#!
#! Inputs:  [a, b, c, d, ...]
#! Outputs: [d, c, b, a, ...]
#!
#! Cycles: 3
export.reverse
	movdn.3
	swap.2
end

#! Returns a boolean indicating whether the input word is [0, 0, 0, 0].
#!
#! Inputs:  [INPUT_WORD]
#! Outputs: [is_word_zero, INPUT_WORD]
#!
#! Where:
#! - INPUT_WORD is the word to compare against [0, 0, 0, 0].
#! - is_empty_word is a boolean indicating whether INPUT_WORD is all zeros.
#!
#! Cycles: 11
export.eqz
    repeat.4
        dup.3 eq.0
    end
    and and and
end

# COMPARISON OPERATIONS
# -------------------------------------------------------------------------------------------------

#! Returns true if LHS is strictly greater than RHS, false otherwise.
#!
#! This compares words using the same ordering as Merkle tree key comparisons.
#!
#! The implementation avoids branching for performance reasons.
#!
#! For reference, this is equivalent to the following Rust function:
#!
#! fn is_key_greater(key1: Word, key2: Word) -> bool {
#!     let mut result = false;
#!     let mut cont = true;
#!
#!     for i in (0..4).rev() {
#!         let gt = key1[i].as_int() > key2[i].as_int();
#!         let eq = key1[i].as_int() == key2[i].as_int();
#!         result |= gt & cont;
#!         cont &= eq;
#!     }
#!
#!     result
#! }
#!
#! Inputs:  [LHS, RHS]
#! Output: [is_lhs_greater]
#!
#! Cycles: 121
export.gt
    exec.arrange_words_adjacent
    # => [2_3, 1_3, 2_2, 1_2, 2_1, 1_1, 2_0, 1_0]

    push.1.0
    # => [is_lhs_greater, continue, 2_3, 1_3, 2_2, 1_2, 2_1, 1_1, 2_0, 1_0]

    repeat.4
        movup.3 movup.3
        # => [2_x, 1_x, is_lhs_greater, continue, <remaining_felts>]

        # check 1_x == 2_x; if so, we continue
        dup dup.2 eq
        # => [is_felt_eq, 2_x, 1_x, is_lhs_greater, continue, <remaining_felts>]

        movdn.3
        # => [2_x, 1_x, is_lhs_greater, is_felt_eq, continue, <remaining_felts>]

        # check 1_x > 2_x
        gt
        # => [is_felt_gt, is_lhs_greater, is_felt_eq, continue, <remaining_felts>]

        dup.3 and
        # => [is_felt_gt_if_continue, is_lhs_greater, is_felt_eq, continue, <remaining_felts>]

        or movdn.2
        # => [is_felt_eq, continue, is_lhs_greater, <remaining_felts>]

        # keeps continue at 1 if the felts are equal
        # sets continue to 0 if the felts are not equal
        and
        # => [continue, is_lhs_greater, <remaining_felts>]

        swap
        # => [is_lhs_greater, continue, <remaining_felts>]
    end
    # => [is_lhs_greater, continue]

    swap drop
    # => [is_lhs_greater]
end

#! Returns true if LHS is greater than or equal to RHS.
#!
#! Inputs:  [LHS, RHS]
#! Output: [is_lhs_greater_or_equal]
#!
#! Cycles: 118
export.gte
    exec.lt
    not
end

#! Returns true if LHS is strictly less than RHS, false otherwise.
#!
#! The implementation avoids branching for performance reasons.
#!
#! From an implementation standpoint this is exactly the same as `word::gt` except it uses
#! `lt` rather than `gt`. See its docs for details.
#!
#! Inputs:  [LHS, RHS]
#! Output: [is_lhs_lesser]
#!
#! Cycles: 117
export.lt
    exec.arrange_words_adjacent
    # => [2_3, 1_3, 2_2, 1_2, 2_1, 1_1, 2_0, 1_0]

    push.1.0
    # => [is_lhs_less, continue, 2_3, 1_3, 2_2, 1_2, 2_1, 1_1, 2_0, 1_0]

    repeat.4
        movup.3 movup.3
        # => [2_x, 1_x, is_lhs_less, continue, <remaining_felts>]

        # check 1_x == 2_x; if so, we continue
        dup dup.2 eq
        # => [is_felt_eq, 2_x, 1_x, is_lhs_less, continue, <remaining_felts>]

        movdn.3
        # => [2_x, 1_x, is_lhs_less, is_felt_eq, continue, <remaining_felts>]

        # check 1_x < 2_x
        lt
        # => [is_felt_lt, is_lhs_less, is_felt_eq, continue, <remaining_felts>]

        dup.3 and
        # => [is_felt_lt_if_continue, is_lhs_less, is_felt_eq, continue, <remaining_felts>]

        or movdn.2
        # => [is_felt_eq, continue, is_lhs_less, <remaining_felts>]

        # keeps continue at 1 if the felts are equal
        # sets continue to 0 if the felts are not equal
        and
        # => [continue, is_lhs_less, <remaining_felts>]

        swap
        # => [is_lhs_less, continue, <remaining_felts>]
    end
    # => [is_lhs_less, continue]

    swap drop
    # => [is_lhs_less]
end

#! Returns true if LHS is less than or equal to RHS.
#!
#! Inputs:  [LHS, RHS]
#! Output: [is_lhs_less_or_equal]
#!
#! Cycles: 122
export.lte
    exec.gt
    not
end

#! Returns true if LHS is exactly equal to RHS, false otherwise.
#!
#! The implementation does not branch, and always performs the same number of comparisons.
#!
#! This is currently equivalent to the eqw instruction.
#!
#! Inputs:  [LHS, RHS]
#! Output: [lhs_eq_rhs]
#!
#! Cycles: 26
export.eq
    # => [l3, l2, l1, l0, r3, r2, r1, l0]
    exec.arrange_words_adjacent
    # => [r3, l3, r2, l2, r1, l1, r0, l0]

    push.1
    # => [lhs_eq_rhs, r3, l3, ...]

    repeat.4
        movup.2 movup.2
        # => [rx, lx, lhs_eq_rhs, ...]
        eq
        # => [rx_eq_lx, lhs_eq_rhs, ...]
        and
        # => [lhs_eq_rhs', ...]
    end

    # => [lhs_eq_rhs]
end

# HELPER PROCEDURES
# -------------------------------------------------------------------------------------------------

#! Arranges the given words such that the corresponding elements are next to each other.
#!
#! Inputs:  [WORD1, WORD2]
#! Outputs: [word2_3, word1_3, word2_2, word1_2, word2_1, word1_1, word2_0, word1_0]
#!
#! Cycles: 8
proc.arrange_words_adjacent
    # => [1_3, 1_2, 1_1, 1_0, 2_3, 2_2, 2_1, 2_0]

    movup.3 movup.7
    # => [2_0, 1_0, 1_3, 1_2, 1_1, 2_3, 2_2, 2_1]

    movup.4 movup.7
    # => [2_1, 1_1, 2_0, 1_0, 1_3, 1_2, 2_3, 2_2]

    movup.5 movup.7
    # => [2_2, 1_2, 2_1, 1_1, 2_0, 1_0, 1_3, 2_3]

    movup.6 movup.7
    # => [2_3, 1_3, 2_2, 1_2, 2_1, 1_1, 2_0, 1_0]
end
